# -*- coding: utf-8 -*-
"""functions.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AeYx1IYdCysxgwg_GzKFiFalgJtvd3dW
"""

def sgn(v):
  v1 = np.sign(v)
  v2 = np.where(v1 < 0, 0, v1)
  return v2

def choose(n,r):
    f = math.factorial
    return f(n) // f(r) // f(n-r)

def MakeListElemsUnique(v):
  list_of_sets = [set(elem) for elem in v]
  unique_list_of_sets = []
  [unique_list_of_sets.append(x) for x in list_of_sets if x not in unique_list_of_sets]
  return unique_list_of_sets

def FindEdges(adj, order=False):
  edges = np.nonzero(adj)
  if len(adj.shape) == 2:
    edges = list(zip(edges[0],edges[1]))
  if len(adj.shape) == 3:
    edges = list(zip(edges[0],edges[1],edges[2]))
  if not order:
    return MakeListElemsUnique(edges)
  else:
    return edges

def GenerateG(degree,min_pos_edges,n):
  force_weights = True
  min_pos_edges = 4
  print_weights = True
  nonneg_edges = True

  if force_weights:
    G = np.zeros((n,n))
    for i in range(n):
      while np.sum(sgn(G[i])) < min_pos_edges:
        G[i] = np.zeros(n)
        num_nodes = random.randint(math.floor(.8*degree),math.floor(1.2*degree))
        while np.sum(np.absolute(G[i])) < num_nodes:
          G[i,random.randint(0,n-1)] = np.sign(random.random()*2 -1)
    G = np.sign(G)
    G = np.transpose(G)

  if not force_weights:
    G = np.zeros((n,n))
    for i in range(n):
      num_nodes = random.randint(math.floor(.8*degree),math.floor(1.2*degree))
      while np.sum(np.absolute(G[i])) < num_nodes:
        G[i,random.randint(0,n-1)] = np.sign(random.random()*2 -1)
    G = np.sign(G)
    G = np.transpose(G)

  if nonneg_edges:
    G = sgn(G)
  
  return G

def GenerateSamples(G, p_input, sample_num):
  samples = []
  for i in range(sample_num):
    h = np.zeros(n)
    num_ones = math.floor(n * p_input)
    while np.sum(h) < num_ones:
      h[random.randint(0,h.size-1)] = 1
    y = sgn(np.matmul(G,h))
    samples.append(y)
  return samples

def ThreewiseGraph(samples, p_input):
  N = len(samples)
  adj = np.zeros((n,n,n))
  a = 0
  for sample in samples:
    a += 1
    fired = np.argwhere(sample)   
    for i in fired:
      for j in fired:
        for k in fired:
          if i[0] != j[0] and i[0] != k[0] and j[0] != k[0]:
            adj[i[0],j[0],k[0]] += 1

  adj = np.where(adj <  2* p_input * N / 3, 0, adj)
  adj = np.where(adj > 0, 1, adj)
  return adj

def RecoverGraph3Wise(adj, degree):
  #Values
  edges = FindEdges(adj)
  edges_duplicate = FindEdges(adj)
  G1 = np.zeros((n,n))
  G1_index = 0
  counter = 0

  large_num = 10000 #to prevent endless loop
  while edges and counter < large_num:  
    counter += 1
    #Pick a random edge
    edge = edges[random.randint(0,len(edges)-1)]
    #print("edge: ",edge)
    edge_copy = edge.copy()
    v1 = edge_copy.pop()
    v2 = edge_copy.pop()
    v3 = edge_copy.pop()

    #Build S
    S = []
    for v in range(n):
      if {v,v1,v2} in edges_duplicate and {v,v2,v3} in edges_duplicate and {v,v1,v3} in edges_duplicate:          #edges_duplicate
        S.append(v)
    S.append(v1)
    S.append(v2)
    S.append(v3)

    #Build S1
    S1 = []
    if len(S) < 1.3 * degree  and len(S) > 0:

      #Find v's in S with enough neighbors for S1
      for v in S:
        neighbors = []
        for neighbor1 in S:
          for neighbor2 in S:
            if {v, neighbor1, neighbor2} in edges_duplicate:                                                     
              neighbors.append((neighbor1,neighbor2))
        
        neighbors = MakeListElemsUnique(neighbors)
        if len(neighbors) >= choose(math.floor(.8 * degree - 1),2):                                                
          S1.append(v)


      #Build G
      if len(S1) > 0:
        for v in S1:
          G1[v,G1_index] = 1
        G1_index += 1
        if G1_index > n-1:
          print("Index overload")
          return G1

      #Remove all edges in a community (S1) from edges_duplicate
      for v1 in S1:
        for v2 in S1:
          for v3 in S1:
            if {v1,v2,v3} in edges:             
              edges.remove({v1,v2,v3})

  return G1

def RecoveredColumns(G, G1):
  found_cols = 0
  G_t = np.transpose(G)
  G1_t = np.transpose(G1)
  for column in G_t:
    if (G1_t == column).all(1).any():
      found_cols += 1
  return found_cols/G.shape[0]

def StatError(G, G1, samples, sample_num, p_input):
  samples_rec = []
  for i in range(sample_num):
    h = np.zeros(n)
    num_ones = math.floor(n * p_input)
    while np.sum(h) < num_ones:
      h[random.randint(0,h.size-1)] = 1
    y = sgn(np.matmul(G1,h))
    samples_rec.append(y)
    
  cov = np.cov(samples,rowvar=False)
  cov_rec = np.cov(samples_rec,rowvar=False)
  diff = cov - cov_rec
  frob_norm_diff = np.linalg.norm(diff)
  frob_norm_cov = np.linalg.norm(cov)
  frob_norm_error = ( frob_norm_cov - frob_norm_diff ) / frob_norm_cov 

  mean = np.mean(np.mean(samples,axis=0))
  mean_diff = np.mean(np.mean(samples,axis=0)-np.mean(samples_rec,axis=0))
  mean_error = ( mean - mean_diff ) / (mean)

  return frob_norm_error, mean_error